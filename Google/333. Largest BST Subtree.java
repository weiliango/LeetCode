/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    int max = 0;    int cur = 0;    public int largestBSTSubtree(TreeNode root) {        traverse(root);        return max;    }    public void traverse(TreeNode root) {        if(root == null) return;        cur = 0;        if(validate(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) {            max = Math.max(max, cur);        }        traverse(root.left);        traverse(root.right);    }    private boolean validate(TreeNode root, int min, int max) {        if(root == null) return true;        if(root.val < min || root.val > max) return false;        if(root.left != null && root.left.val >= root.val)            return false;        if(root.right != null && root.right.val <= root.val)            return false;        cur += 1;        return validate(root.left, min, root.val) && validate(root.right, root.val, max);    }}class Solution {    int max = 0;    int cur = 0;    public int largestBSTSubtree(TreeNode root) {        traverse(root);        return max;    }    public void traverse(TreeNode root) {        if(root == null) return;        cur = 0;        if(validate(root, Integer.MIN_VALUE, Integer.MAX_VALUE)) {            max = Math.max(max, cur);        } else {            traverse(root.left);            traverse(root.right);        }    }    private boolean validate(TreeNode root, int min, int max) {        if(root == null) return true;        if(root.val < min || root.val > max) return false;        if(root.left != null && root.left.val >= root.val)            return false;        if(root.right != null && root.right.val <= root.val)            return false;        cur += 1;        return validate(root.left, min, root.val) && validate(root.right, root.val, max);    }}